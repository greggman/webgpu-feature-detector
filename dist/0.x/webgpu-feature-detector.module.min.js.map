{"version":3,"file":"webgpu-feature-detector.module.min.js","sources":["../../../src/utils.ts","../../../src/format_info.ts","../../../src/webgpu-feature-detector.ts"],"sourcesContent":["export const roundUpToMultipleOf = (v: number, multiple: number) => (((v + multiple - 1) / multiple) | 0) * multiple;\n\nexport function keysOf<T extends string>(obj: { [k in T]: unknown }): readonly T[] {\n  return (Object.keys(obj) as unknown[]) as T[];\n}\n\nexport function range<T>(count: number, fn: (i: number) => T) {\n    return new Array(count).fill(0).map((_, i) => fn(i));\n}\n\nconst isIterable = (v: any) =>\n  v !== null && typeof v[Symbol.iterator] === 'function';\n\nexport function normalizeExtent3D(extent: GPUExtent3D): [number, number, number] {\n  if (!extent) {\n    return [1, 1, 1];\n  }\n  if (isIterable(extent)) {\n    const [w, h = 1, d = 1] = [...extent as number[]];\n    return [w, h, d];\n  }\n  const { width = 1, height = 1, depthOrArrayLayers = 1 } = extent as GPUExtent3DDict;\n  return [width, height, depthOrArrayLayers];\n}\n\nexport function normalizeOrigin3D(origin?: GPUOrigin3D): [number, number, number] {\n  if (!origin) {\n    return [0, 0, 0];\n  }\n  if (isIterable(origin)) {\n    const [x, y = 0, z = 0] = [...origin as number[]];\n    return [x, y, z];\n  }\n  const { x = 0, y = 0, z = 0 } = origin as GPUOrigin3DDict;\n  return [x, y, z];\n}\n\nexport function addOrigin3D(a?: GPUOrigin3D, b?: GPUOrigin3D): [number, number, number] {\n  const an = normalizeOrigin3D(a);\n  const bn = normalizeOrigin3D(b);\n  return an.map((v, i) => v + bn[i]) as [number, number, number];\n}\n\nexport function hasFeature(features: GPUSupportedFeatures, feature: GPUFeatureName) {\n  // eslint-disable-next-line no-restricted-syntax\n  return features.has(feature);\n}\n\n/** Round `n` up to the next multiple of `alignment` (inclusive). */\nexport function align(n: number, alignment: number): number {\n  return Math.ceil(n / alignment) * alignment;\n}\n\n/** Round `n` down to the next multiple of `alignment` (inclusive). */\nexport function roundDown(n: number, alignment: number): number {\n  return Math.floor(n / alignment) * alignment;\n}\n\nexport function isCompatibilityMode(features: GPUSupportedFeatures) {\n  return !features.has('core-features-and-limits');\n}\n\n/**\n * Get texture dimension from view dimension in order to create an compatible texture for a given\n * view dimension.\n */\nexport function getTextureDimensionFromView(viewDimension: GPUTextureViewDimension) {\n  switch (viewDimension) {\n    case '1d':\n      return '1d';\n    case '2d':\n    case '2d-array':\n    case 'cube':\n    case 'cube-array':\n      return '2d';\n    case '3d':\n      return '3d';\n    default:\n      throw new Error('bad view dimension');\n  }\n}","/*\nThis file is a modified version of a file from the WebGPU CTS\n\nCopyright 2019 WebGPU CTS Contributors\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n   1. Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n   2. Redistributions in binary form must reproduce the above copyright notice,\n      this list of conditions and the following disclaimer in the documentation\n      and/or other materials provided with the distribution.\n\n   3. Neither the name of the copyright holder nor the names of its\n      contributors may be used to endorse or promote products derived from this\n      software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n */\nimport {\n  align,\n  getTextureDimensionFromView,\n  hasFeature,\n  isCompatibilityMode,\n  keysOf,\n  roundDown,\n} from './utils.js';\n\nfunction assert(condition: boolean, msg?: string | (() => string)): asserts condition {\n  if (!condition) {\n    throw new Error(typeof msg === 'function' ? msg() : msg);\n  }\n}\n\nexport function unreachable(msg?: string): never {\n  throw new Error(msg);\n}\n\nexport type ImageCopyType = 'WriteTexture' | 'CopyB2T' | 'CopyT2B';\nexport const kImageCopyTypes: readonly ImageCopyType[] = [\n  'WriteTexture',\n  'CopyB2T',\n  'CopyT2B',\n] as const;\n\n// --- cut here ---\n\n//\n// Texture format tables\n//\n\n/**\n * Defaults applied to all texture format tables automatically. Used only inside\n * `formatTableWithDefaults`. This ensures keys are never missing, always explicitly `undefined`.\n *\n * All top-level keys must be defined here, or they won't be exposed at all.\n * Documentation is also written here; this makes it propagate through to the end types.\n */\nconst kFormatUniversalDefaults = {\n  /** Texel block width. */\n  blockWidth: undefined,\n  /** Texel block height. */\n  blockHeight: undefined,\n  color: undefined,\n  depth: undefined,\n  stencil: undefined,\n  /**\n   * Info when this format can be used as a color render target. The format may require a feature\n   * to actually be used as a render target. Eg: rg11b10ufloat which requires rg11b10ufloat-renderable\n   * Call {@link isTextureFormatPossiblyUsableAsColorRenderAttachment} before having a device\n   * Call {@link isTextureFormatColorRenderable}(device, format) to find out for a particular device.\n   * Use {@link kPossibleColorRenderableTextureFormats} for params.\n   */\n  colorRender: undefined,\n  /**\n   * Whether the format can possibly be used as a multisample texture. The format may require a\n   * feature to actually multisampled. Eg: rg11b10ufloat which requires rg11b10ufloat-renderable\n   * Call {@link isTextureFormatPossiblyMultisampled} before having a device\n   * Call {@link isTextureFormatMultisampled}(device, format) to find out for a particular device.\n   * Use {@link kPossibleMultisampledTextureFormats} for params.\n   */\n  multisample: undefined,\n  /** Optional feature required to use this format, or `undefined` if none. */\n  feature: undefined,\n  /** The base format for srgb formats. Specified on both srgb and equivalent non-srgb formats. */\n  baseFormat: undefined,\n\n  /** @deprecated Use `.color.bytes`, `.depth.bytes`, or `.stencil.bytes`. */\n  bytesPerBlock: undefined,\n\n  // IMPORTANT:\n  // Add new top-level keys both here and in TextureFormatInfo_TypeCheck.\n} as const;\n/**\n * Takes `table` and applies `defaults` to every row, i.e. for each row,\n * `{ ... kUniversalDefaults, ...defaults, ...row }`.\n * This only operates at the first level; it doesn't support defaults in nested objects.\n */\nfunction formatTableWithDefaults<Defaults extends {}, Table extends { readonly [K: string]: {} }>({\n  defaults,\n  table,\n}: {\n  defaults: Defaults;\n  table: Table;\n}): {\n  readonly [F in keyof Table]: {\n    readonly [K in keyof typeof kFormatUniversalDefaults]: K extends keyof Table[F]\n      ? Table[F][K]\n      : K extends keyof Defaults\n      ? Defaults[K]\n      : (typeof kFormatUniversalDefaults)[K];\n  };\n} {\n  return Object.fromEntries(\n    Object.entries(table).map(([k, row]) => [\n      k,\n      { ...kFormatUniversalDefaults, ...defaults, ...row },\n    ])\n    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n  ) as any;\n}\n\n/** \"plain color formats\", plus rgb9e5ufloat. */\nconst kRegularTextureFormatInfo = formatTableWithDefaults({\n  defaults: { blockWidth: 1, blockHeight: 1 },\n  table: {\n    // plain, 8 bits per component\n\n    r8unorm: {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 1,\n      },\n      colorRender: { blend: true, resolve: true, byteCost: 1, alignment: 1 },\n      multisample: true,\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    r8snorm: {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 1,\n      },\n      multisample: false,\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    r8uint: {\n      color: {\n        type: 'uint',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 1,\n      },\n      colorRender: { blend: false, resolve: false, byteCost: 1, alignment: 1 },\n      multisample: true,\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    r8sint: {\n      color: {\n        type: 'sint',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 1,\n      },\n      colorRender: { blend: false, resolve: false, byteCost: 1, alignment: 1 },\n      multisample: true,\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n\n    rg8unorm: {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 2,\n      },\n      colorRender: { blend: true, resolve: true, byteCost: 2, alignment: 1 },\n      multisample: true,\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    rg8snorm: {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 2,\n      },\n      multisample: false,\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    rg8uint: {\n      color: {\n        type: 'uint',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 2,\n      },\n      colorRender: { blend: false, resolve: false, byteCost: 2, alignment: 1 },\n      multisample: true,\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    rg8sint: {\n      color: {\n        type: 'sint',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 2,\n      },\n      colorRender: { blend: false, resolve: false, byteCost: 2, alignment: 1 },\n      multisample: true,\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n\n    rgba8unorm: {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: true,\n        readWriteStorage: false,\n        bytes: 4,\n      },\n      colorRender: { blend: true, resolve: true, byteCost: 8, alignment: 1 },\n      multisample: true,\n      baseFormat: 'rgba8unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    'rgba8unorm-srgb': {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 4,\n      },\n      colorRender: { blend: true, resolve: true, byteCost: 8, alignment: 1 },\n      multisample: true,\n      baseFormat: 'rgba8unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    rgba8snorm: {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: true,\n        readWriteStorage: false,\n        bytes: 4,\n      },\n      multisample: false,\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    rgba8uint: {\n      color: {\n        type: 'uint',\n        copySrc: true,\n        copyDst: true,\n        storage: true,\n        readWriteStorage: false,\n        bytes: 4,\n      },\n      colorRender: { blend: false, resolve: false, byteCost: 4, alignment: 1 },\n      multisample: true,\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    rgba8sint: {\n      color: {\n        type: 'sint',\n        copySrc: true,\n        copyDst: true,\n        storage: true,\n        readWriteStorage: false,\n        bytes: 4,\n      },\n      colorRender: { blend: false, resolve: false, byteCost: 4, alignment: 1 },\n      multisample: true,\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    bgra8unorm: {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 4,\n      },\n      colorRender: { blend: true, resolve: true, byteCost: 8, alignment: 1 },\n      multisample: true,\n      baseFormat: 'bgra8unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    'bgra8unorm-srgb': {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 4,\n      },\n      colorRender: { blend: true, resolve: true, byteCost: 8, alignment: 1 },\n      multisample: true,\n      baseFormat: 'bgra8unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n\n    // plain, 16 bits per component\n\n    r16unorm: {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: true,\n        readWriteStorage: false,\n        bytes: 2,\n      },\n      colorRender: { blend: true, resolve: false, byteCost: 2, alignment: 2 },\n      multisample: true,\n      feature: 'texture-formats-tier1',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    r16snorm: {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: true,\n        readWriteStorage: false,\n        bytes: 2,\n      },\n      colorRender: { blend: true, resolve: false, byteCost: 2, alignment: 2 },\n      multisample: true,\n      feature: 'texture-formats-tier1',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    r16uint: {\n      color: {\n        type: 'uint',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 2,\n      },\n      colorRender: { blend: false, resolve: false, byteCost: 2, alignment: 2 },\n      multisample: true,\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    r16sint: {\n      color: {\n        type: 'sint',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 2,\n      },\n      colorRender: { blend: false, resolve: false, byteCost: 2, alignment: 2 },\n      multisample: true,\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    r16float: {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 2,\n      },\n      colorRender: { blend: true, resolve: true, byteCost: 2, alignment: 2 },\n      multisample: true,\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n\n    rg16unorm: {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: true,\n        readWriteStorage: false,\n        bytes: 4,\n      },\n      colorRender: { blend: true, resolve: false, byteCost: 4, alignment: 2 },\n      multisample: true,\n      feature: 'texture-formats-tier1',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    rg16snorm: {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: true,\n        readWriteStorage: false,\n        bytes: 4,\n      },\n      colorRender: { blend: true, resolve: false, byteCost: 4, alignment: 2 },\n      multisample: true,\n      feature: 'texture-formats-tier1',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    rg16uint: {\n      color: {\n        type: 'uint',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 4,\n      },\n      colorRender: { blend: false, resolve: false, byteCost: 4, alignment: 2 },\n      multisample: true,\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    rg16sint: {\n      color: {\n        type: 'sint',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 4,\n      },\n      colorRender: { blend: false, resolve: false, byteCost: 4, alignment: 2 },\n      multisample: true,\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    rg16float: {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 4,\n      },\n      colorRender: { blend: true, resolve: true, byteCost: 4, alignment: 2 },\n      multisample: true,\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n\n    rgba16unorm: {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: true,\n        readWriteStorage: false,\n        bytes: 8,\n      },\n      colorRender: { blend: true, resolve: false, byteCost: 8, alignment: 4 },\n      multisample: true,\n      feature: 'texture-formats-tier1',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    rgba16snorm: {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: true,\n        readWriteStorage: false,\n        bytes: 8,\n      },\n      colorRender: { blend: true, resolve: false, byteCost: 8, alignment: 2 },\n      multisample: true,\n      feature: 'texture-formats-tier1',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    rgba16uint: {\n      color: {\n        type: 'uint',\n        copySrc: true,\n        copyDst: true,\n        storage: true,\n        readWriteStorage: false,\n        bytes: 8,\n      },\n      colorRender: { blend: false, resolve: false, byteCost: 8, alignment: 2 },\n      multisample: true,\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    rgba16sint: {\n      color: {\n        type: 'sint',\n        copySrc: true,\n        copyDst: true,\n        storage: true,\n        readWriteStorage: false,\n        bytes: 8,\n      },\n      colorRender: { blend: false, resolve: false, byteCost: 8, alignment: 2 },\n      multisample: true,\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    rgba16float: {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: true,\n        readWriteStorage: false,\n        bytes: 8,\n      },\n      colorRender: { blend: true, resolve: true, byteCost: 8, alignment: 2 },\n      multisample: true,\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n\n    // plain, 32 bits per component\n\n    r32uint: {\n      color: {\n        type: 'uint',\n        copySrc: true,\n        copyDst: true,\n        storage: true,\n        readWriteStorage: true,\n        bytes: 4,\n      },\n      colorRender: { blend: false, resolve: false, byteCost: 4, alignment: 4 },\n      multisample: false,\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    r32sint: {\n      color: {\n        type: 'sint',\n        copySrc: true,\n        copyDst: true,\n        storage: true,\n        readWriteStorage: true,\n        bytes: 4,\n      },\n      colorRender: { blend: false, resolve: false, byteCost: 4, alignment: 4 },\n      multisample: false,\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    r32float: {\n      color: {\n        type: 'unfilterable-float',\n        copySrc: true,\n        copyDst: true,\n        storage: true,\n        readWriteStorage: true,\n        bytes: 4,\n      },\n      colorRender: { blend: false, resolve: false, byteCost: 4, alignment: 4 },\n      multisample: true,\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n\n    rg32uint: {\n      color: {\n        type: 'uint',\n        copySrc: true,\n        copyDst: true,\n        storage: true,\n        readWriteStorage: false,\n        bytes: 8,\n      },\n      colorRender: { blend: false, resolve: false, byteCost: 8, alignment: 4 },\n      multisample: false,\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    rg32sint: {\n      color: {\n        type: 'sint',\n        copySrc: true,\n        copyDst: true,\n        storage: true,\n        readWriteStorage: false,\n        bytes: 8,\n      },\n      colorRender: { blend: false, resolve: false, byteCost: 8, alignment: 4 },\n      multisample: false,\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    rg32float: {\n      color: {\n        type: 'unfilterable-float',\n        copySrc: true,\n        copyDst: true,\n        storage: true,\n        readWriteStorage: false,\n        bytes: 8,\n      },\n      colorRender: { blend: false, resolve: false, byteCost: 8, alignment: 4 },\n      multisample: false,\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n\n    rgba32uint: {\n      color: {\n        type: 'uint',\n        copySrc: true,\n        copyDst: true,\n        storage: true,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      colorRender: { blend: false, resolve: false, byteCost: 16, alignment: 4 },\n      multisample: false,\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    rgba32sint: {\n      color: {\n        type: 'sint',\n        copySrc: true,\n        copyDst: true,\n        storage: true,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      colorRender: { blend: false, resolve: false, byteCost: 16, alignment: 4 },\n      multisample: false,\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    rgba32float: {\n      color: {\n        type: 'unfilterable-float',\n        copySrc: true,\n        copyDst: true,\n        storage: true,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      colorRender: { blend: false, resolve: false, byteCost: 16, alignment: 4 },\n      multisample: false,\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n\n    // plain, mixed component width, 32 bits per texel\n\n    rgb10a2uint: {\n      color: {\n        type: 'uint',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 4,\n      },\n      colorRender: { blend: false, resolve: false, byteCost: 8, alignment: 4 },\n      multisample: true,\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    rgb10a2unorm: {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 4,\n      },\n      colorRender: { blend: true, resolve: true, byteCost: 8, alignment: 4 },\n      multisample: true,\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    rg11b10ufloat: {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 4,\n      },\n      colorRender: { blend: true, resolve: true, byteCost: 8, alignment: 4 },\n      multisample: true,\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n\n    // packed\n\n    rgb9e5ufloat: {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 4,\n      },\n      multisample: false,\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n  },\n} as const);\n\n// MAINTENANCE_TODO: Distinguishing \"sized\" and \"unsized\" depth stencil formats doesn't make sense\n// because one aspect can be sized and one can be unsized. This should be cleaned up, but is kept\n// this way during a migration phase.\nconst kSizedDepthStencilFormatInfo = formatTableWithDefaults({\n  defaults: { blockWidth: 1, blockHeight: 1, multisample: true },\n  table: {\n    stencil8: {\n      stencil: {\n        type: 'uint',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 1,\n      },\n      bytesPerBlock: 1,\n    },\n    depth16unorm: {\n      depth: {\n        type: 'depth',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 2,\n      },\n      bytesPerBlock: 2,\n    },\n    depth32float: {\n      depth: {\n        type: 'depth',\n        copySrc: true,\n        copyDst: false,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 4,\n      },\n      bytesPerBlock: 4,\n    },\n  },\n} as const);\nconst kUnsizedDepthStencilFormatInfo = formatTableWithDefaults({\n  defaults: { blockWidth: 1, blockHeight: 1, multisample: true },\n  table: {\n    depth24plus: {\n      depth: {\n        type: 'depth',\n        copySrc: false,\n        copyDst: false,\n        storage: false,\n        readWriteStorage: false,\n        bytes: undefined,\n      },\n    },\n    'depth24plus-stencil8': {\n      depth: {\n        type: 'depth',\n        copySrc: false,\n        copyDst: false,\n        storage: false,\n        readWriteStorage: false,\n        bytes: undefined,\n      },\n      stencil: {\n        type: 'uint',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 1,\n      },\n    },\n    'depth32float-stencil8': {\n      depth: {\n        type: 'depth',\n        copySrc: true,\n        copyDst: false,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 4,\n      },\n      stencil: {\n        type: 'uint',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 1,\n      },\n      feature: 'depth32float-stencil8',\n    },\n  },\n} as const);\n\nconst kBCTextureFormatInfo = formatTableWithDefaults({\n  defaults: {\n    blockWidth: 4,\n    blockHeight: 4,\n    multisample: false,\n    feature: 'texture-compression-bc',\n  },\n  table: {\n    'bc1-rgba-unorm': {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 8,\n      },\n      baseFormat: 'bc1-rgba-unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    'bc1-rgba-unorm-srgb': {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 8,\n      },\n      baseFormat: 'bc1-rgba-unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n\n    'bc2-rgba-unorm': {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      baseFormat: 'bc2-rgba-unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    'bc2-rgba-unorm-srgb': {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      baseFormat: 'bc2-rgba-unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n\n    'bc3-rgba-unorm': {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      baseFormat: 'bc3-rgba-unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    'bc3-rgba-unorm-srgb': {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      baseFormat: 'bc3-rgba-unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n\n    'bc4-r-unorm': {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 8,\n      },\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    'bc4-r-snorm': {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 8,\n      },\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n\n    'bc5-rg-unorm': {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    'bc5-rg-snorm': {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n\n    'bc6h-rgb-ufloat': {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    'bc6h-rgb-float': {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n\n    'bc7-rgba-unorm': {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      baseFormat: 'bc7-rgba-unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    'bc7-rgba-unorm-srgb': {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      baseFormat: 'bc7-rgba-unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n  },\n} as const);\n\nconst kETC2TextureFormatInfo = formatTableWithDefaults({\n  defaults: {\n    blockWidth: 4,\n    blockHeight: 4,\n    multisample: false,\n    feature: 'texture-compression-etc2',\n  },\n  table: {\n    'etc2-rgb8unorm': {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 8,\n      },\n      baseFormat: 'etc2-rgb8unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    'etc2-rgb8unorm-srgb': {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 8,\n      },\n      baseFormat: 'etc2-rgb8unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n\n    'etc2-rgb8a1unorm': {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 8,\n      },\n      baseFormat: 'etc2-rgb8a1unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    'etc2-rgb8a1unorm-srgb': {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 8,\n      },\n      baseFormat: 'etc2-rgb8a1unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n\n    'etc2-rgba8unorm': {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      baseFormat: 'etc2-rgba8unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    'etc2-rgba8unorm-srgb': {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      baseFormat: 'etc2-rgba8unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n\n    'eac-r11unorm': {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 8,\n      },\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    'eac-r11snorm': {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 8,\n      },\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n\n    'eac-rg11unorm': {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    'eac-rg11snorm': {\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n  },\n} as const);\n\nconst kASTCTextureFormatInfo = formatTableWithDefaults({\n  defaults: {\n    multisample: false,\n    feature: 'texture-compression-astc',\n  },\n  table: {\n    'astc-4x4-unorm': {\n      blockWidth: 4,\n      blockHeight: 4,\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      baseFormat: 'astc-4x4-unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    'astc-4x4-unorm-srgb': {\n      blockWidth: 4,\n      blockHeight: 4,\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      baseFormat: 'astc-4x4-unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n\n    'astc-5x4-unorm': {\n      blockWidth: 5,\n      blockHeight: 4,\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      baseFormat: 'astc-5x4-unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    'astc-5x4-unorm-srgb': {\n      blockWidth: 5,\n      blockHeight: 4,\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      baseFormat: 'astc-5x4-unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n\n    'astc-5x5-unorm': {\n      blockWidth: 5,\n      blockHeight: 5,\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      baseFormat: 'astc-5x5-unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    'astc-5x5-unorm-srgb': {\n      blockWidth: 5,\n      blockHeight: 5,\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      baseFormat: 'astc-5x5-unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n\n    'astc-6x5-unorm': {\n      blockWidth: 6,\n      blockHeight: 5,\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      baseFormat: 'astc-6x5-unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    'astc-6x5-unorm-srgb': {\n      blockWidth: 6,\n      blockHeight: 5,\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      baseFormat: 'astc-6x5-unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n\n    'astc-6x6-unorm': {\n      blockWidth: 6,\n      blockHeight: 6,\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      baseFormat: 'astc-6x6-unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    'astc-6x6-unorm-srgb': {\n      blockWidth: 6,\n      blockHeight: 6,\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      baseFormat: 'astc-6x6-unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n\n    'astc-8x5-unorm': {\n      blockWidth: 8,\n      blockHeight: 5,\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      baseFormat: 'astc-8x5-unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    'astc-8x5-unorm-srgb': {\n      blockWidth: 8,\n      blockHeight: 5,\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      baseFormat: 'astc-8x5-unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n\n    'astc-8x6-unorm': {\n      blockWidth: 8,\n      blockHeight: 6,\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      baseFormat: 'astc-8x6-unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    'astc-8x6-unorm-srgb': {\n      blockWidth: 8,\n      blockHeight: 6,\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      baseFormat: 'astc-8x6-unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n\n    'astc-8x8-unorm': {\n      blockWidth: 8,\n      blockHeight: 8,\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      baseFormat: 'astc-8x8-unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    'astc-8x8-unorm-srgb': {\n      blockWidth: 8,\n      blockHeight: 8,\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      baseFormat: 'astc-8x8-unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n\n    'astc-10x5-unorm': {\n      blockWidth: 10,\n      blockHeight: 5,\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      baseFormat: 'astc-10x5-unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    'astc-10x5-unorm-srgb': {\n      blockWidth: 10,\n      blockHeight: 5,\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      baseFormat: 'astc-10x5-unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n\n    'astc-10x6-unorm': {\n      blockWidth: 10,\n      blockHeight: 6,\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      baseFormat: 'astc-10x6-unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    'astc-10x6-unorm-srgb': {\n      blockWidth: 10,\n      blockHeight: 6,\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      baseFormat: 'astc-10x6-unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n\n    'astc-10x8-unorm': {\n      blockWidth: 10,\n      blockHeight: 8,\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      baseFormat: 'astc-10x8-unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    'astc-10x8-unorm-srgb': {\n      blockWidth: 10,\n      blockHeight: 8,\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      baseFormat: 'astc-10x8-unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n\n    'astc-10x10-unorm': {\n      blockWidth: 10,\n      blockHeight: 10,\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      baseFormat: 'astc-10x10-unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    'astc-10x10-unorm-srgb': {\n      blockWidth: 10,\n      blockHeight: 10,\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      baseFormat: 'astc-10x10-unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n\n    'astc-12x10-unorm': {\n      blockWidth: 12,\n      blockHeight: 10,\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      baseFormat: 'astc-12x10-unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    'astc-12x10-unorm-srgb': {\n      blockWidth: 12,\n      blockHeight: 10,\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      baseFormat: 'astc-12x10-unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n\n    'astc-12x12-unorm': {\n      blockWidth: 12,\n      blockHeight: 12,\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      baseFormat: 'astc-12x12-unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n    'astc-12x12-unorm-srgb': {\n      blockWidth: 12,\n      blockHeight: 12,\n      color: {\n        type: 'float',\n        copySrc: true,\n        copyDst: true,\n        storage: false,\n        readWriteStorage: false,\n        bytes: 16,\n      },\n      baseFormat: 'astc-12x12-unorm',\n      /*prettier-ignore*/ get bytesPerBlock() { return this.color.bytes; },\n    },\n  },\n} as const);\n\n// Definitions for use locally.\n\n// MAINTENANCE_TODO: Consider generating the exports below programmatically by filtering the big list, instead\n// of using these local constants? Requires some type magic though.\n/* prettier-ignore */ const   kCompressedTextureFormatInfo = { ...kBCTextureFormatInfo, ...kETC2TextureFormatInfo, ...kASTCTextureFormatInfo } as const;\n/* prettier-ignore */ const        kColorTextureFormatInfo = { ...kRegularTextureFormatInfo, ...kCompressedTextureFormatInfo } as const;\n/* prettier-ignore */ const    kEncodableTextureFormatInfo = { ...kRegularTextureFormatInfo, ...kSizedDepthStencilFormatInfo } as const;\n/* prettier-ignore */ const        kSizedTextureFormatInfo = { ...kRegularTextureFormatInfo, ...kSizedDepthStencilFormatInfo, ...kCompressedTextureFormatInfo } as const;\n/* prettier-ignore */ const        kDepthStencilFormatInfo = { ...kSizedDepthStencilFormatInfo, ...kUnsizedDepthStencilFormatInfo } as const;\n/* prettier-ignore */ const kUncompressedTextureFormatInfo = { ...kRegularTextureFormatInfo, ...kSizedDepthStencilFormatInfo, ...kUnsizedDepthStencilFormatInfo } as const;\n/* prettier-ignore */ const          kAllTextureFormatInfo = { ...kUncompressedTextureFormatInfo, ...kCompressedTextureFormatInfo } as const;\n\n/** A \"regular\" texture format (uncompressed, sized, single-plane color formats). */\n/* prettier-ignore */ export type      RegularTextureFormat = keyof typeof kRegularTextureFormatInfo;\n/** A sized depth/stencil texture format. */\n/* prettier-ignore */ export type   SizedDepthStencilFormat = keyof typeof kSizedDepthStencilFormatInfo;\n/** An unsized depth/stencil texture format. */\n/* prettier-ignore */ export type UnsizedDepthStencilFormat = keyof typeof kUnsizedDepthStencilFormatInfo;\n/** A compressed (block) texture format. */\n/* prettier-ignore */ export type   CompressedTextureFormat = keyof typeof kCompressedTextureFormatInfo;\n\n/** A color texture format (regular | compressed). */\n/* prettier-ignore */ export type        ColorTextureFormat = keyof typeof kColorTextureFormatInfo;\n/** An encodable texture format (regular | sized depth/stencil). */\n/* prettier-ignore */ export type    EncodableTextureFormat = keyof typeof kEncodableTextureFormatInfo;\n/** A sized texture format (regular | sized depth/stencil | compressed). */\n/* prettier-ignore */ export type        SizedTextureFormat = keyof typeof kSizedTextureFormatInfo;\n/** A depth/stencil format (sized | unsized). */\n/* prettier-ignore */ export type        DepthStencilFormat = keyof typeof kDepthStencilFormatInfo;\n/** An uncompressed (block size 1x1) format (regular | depth/stencil). */\n/* prettier-ignore */ export type UncompressedTextureFormat = keyof typeof kUncompressedTextureFormatInfo;\n\n/* prettier-ignore */ export const        kRegularTextureFormats: readonly      RegularTextureFormat[] = keysOf(     kRegularTextureFormatInfo);\n/* prettier-ignore */ export const     kSizedDepthStencilFormats: readonly   SizedDepthStencilFormat[] = keysOf(  kSizedDepthStencilFormatInfo);\n/* prettier-ignore */ export const   kUnsizedDepthStencilFormats: readonly UnsizedDepthStencilFormat[] = keysOf(kUnsizedDepthStencilFormatInfo);\n/* prettier-ignore */ export const     kCompressedTextureFormats: readonly   CompressedTextureFormat[] = keysOf(  kCompressedTextureFormatInfo);\n/* prettier-ignore */ export const   kBCCompressedTextureFormats: readonly   CompressedTextureFormat[] = keysOf(          kBCTextureFormatInfo);\n/* prettier-ignore */ export const kASTCCompressedTextureFormats: readonly   CompressedTextureFormat[] = keysOf(        kASTCTextureFormatInfo);\n\n/* prettier-ignore */ export const        kColorTextureFormats: readonly        ColorTextureFormat[] = keysOf(       kColorTextureFormatInfo);\n/* prettier-ignore */ export const    kEncodableTextureFormats: readonly    EncodableTextureFormat[] = keysOf(   kEncodableTextureFormatInfo);\n/* prettier-ignore */ export const        kSizedTextureFormats: readonly        SizedTextureFormat[] = keysOf(       kSizedTextureFormatInfo);\n/* prettier-ignore */ export const        kDepthStencilFormats: readonly        DepthStencilFormat[] = keysOf(       kDepthStencilFormatInfo);\n/* prettier-ignore */ export const kUncompressedTextureFormats: readonly UncompressedTextureFormat[] = keysOf(kUncompressedTextureFormatInfo);\n/* prettier-ignore */ export const          kAllTextureFormats: readonly          GPUTextureFormat[] = keysOf(         kAllTextureFormatInfo);\n\n/** Per-GPUTextureFormat-per-aspect info. */\ninterface TextureFormatAspectInfo {\n  /** Whether the aspect can be used as `COPY_SRC`. */\n  copySrc: boolean;\n  /** Whether the aspect can be used as `COPY_DST`. */\n  copyDst: boolean;\n  /** Whether the aspect can be used as `STORAGE`. */\n  storage: boolean;\n  /** Whether the aspect can be used as `STORAGE` with `read-write` storage texture access. */\n  readWriteStorage: boolean;\n  /** The \"texel block copy footprint\" of one texel block; `undefined` if the aspect is unsized. */\n  bytes: number | undefined;\n}\n/** Per GPUTextureFormat-per-aspect info for color aspects. */\ninterface TextureFormatColorAspectInfo extends TextureFormatAspectInfo {\n  bytes: number;\n  /** \"Best\" sample type of the format. \"float\" also implies \"unfilterable-float\". */\n  type: 'float' | 'uint' | 'sint' | 'unfilterable-float';\n}\n/** Per GPUTextureFormat-per-aspect info for depth aspects. */\ninterface TextureFormatDepthAspectInfo extends TextureFormatAspectInfo {\n  /** \"depth\" also implies \"unfilterable-float\". */\n  type: 'depth';\n}\n/** Per GPUTextureFormat-per-aspect info for stencil aspects. */\ninterface TextureFormatStencilAspectInfo extends TextureFormatAspectInfo {\n  bytes: 1;\n  type: 'uint';\n}\n\n/**\n * Per-GPUTextureFormat info.\n * This is not actually the type of values in kTextureFormatInfo; that type is fully const\n * so that it can be narrowed very precisely at usage sites by the compiler.\n * This type exists only as a type check on the inferred type of kTextureFormatInfo.\n */\ntype TextureFormatInfo_TypeCheck = {\n  blockWidth: number;\n  blockHeight: number;\n  multisample: boolean;\n  baseFormat: GPUTextureFormat | undefined;\n  feature: GPUFeatureName | undefined;\n\n  bytesPerBlock: number | undefined;\n\n  // IMPORTANT:\n  // Add new top-level keys both here and in kUniversalDefaults.\n} & (\n  | {\n      /** Color aspect info. */\n      color: TextureFormatColorAspectInfo;\n      /** Defined if the format is a color format that can be used as `RENDER_ATTACHMENT`. */\n      colorRender:\n        | undefined\n        | {\n            /** Whether the format is blendable. */\n            blend: boolean;\n            /** Whether the format can be a multisample resolve target. */\n            resolve: boolean;\n            /** The \"render target pixel byte cost\" of the format. */\n            byteCost: number;\n            /** The \"render target component alignment\" of the format. */\n            alignment: number;\n          };\n    }\n  | (\n      | {\n          /** Depth aspect info. */\n          depth: TextureFormatDepthAspectInfo;\n          /** Stencil aspect info. */\n          stencil: undefined | TextureFormatStencilAspectInfo;\n          multisample: true;\n        }\n      | {\n          /** Stencil aspect info. */\n          stencil: TextureFormatStencilAspectInfo;\n          multisample: true;\n        }\n    )\n);\n\n/**\n * DO NOT EXPORT THIS - functions that need info from this table should use the appropriate\n * method for their needs.\n *\n * For a list of textures formats for test parameters there are:\n *\n * Lists of formats that might require features to be enabled\n * * kPossibleColorRenderableTextureFormats\n * * kPossibleStorageTextureFormats\n * * kPossibleReadWriteStorageTextureFormats\n * * kPossibleMultisampledTextureFormats\n *\n * Lists of formats that end in -srgb\n * * kDifferentBaseFormatTextureFormats  (includes compressed textures)\n * * kDifferentBaseFormatRegularTextureFormats (does not include compressed textures)\n *\n * Formats that require a feature to use at all (mostly compressed formats)\n * * kOptionalTextureFormats\n *\n * Misc\n * * kRegularTextureFormats\n * * kSizedDepthStencilFormats\n * * kUnsizedDepthStencilFormats\n * * kCompressedTextureFormats\n * * kUncompressedTextureFormats\n * * kColorTextureFormats - color formats including compressed and sint/uint\n * * kEncodableTextureFormats - formats that TexelView supports.\n * * kSizedTextureFormats - formats that have a known size (so not depth24plus ...)\n * * kDepthStencilFormats - depth, stencil, depth-stencil\n * * kDepthTextureFormats - depth and depth-stencil\n * * kStencilTextureFormats - stencil and depth-stencil\n * * kAllTextureFormats\n *\n * If one of the list above does not work, add a new one or to filter in beforeAllSubcases you generally want to use\n * You will not know if you can actually use a texture for the given use case until the test runs and has a device.\n *\n * * isTextureFormatPossiblyUsableAsRenderAttachment\n * * isTextureFormatPossiblyUsableAsColorRenderAttachment\n * * isTextureFormatPossiblyMultisampled\n * * isTextureFormatPossiblyStorageReadable\n * * isTextureFormatPossiblyStorageReadWritable\n * * isTextureFormatPossiblyFilterableAsTextureF32\n * * isTextureFormatPossiblyUsableWithCopyExternalImageToTexture\n *\n * These are also usable before or during a test\n *\n * * isColorTextureFormat\n * * isDepthTextureFormat\n * * isStencilTextureFormat\n * * isDepthOrStencilTextureFormat\n * * isEncodableTextureFormat\n * * isRegularTextureFormat\n * * isCompressedFloatTextureFormat\n * * isSintOrUintFormat\n *\n * To skip a test use the `skipIfXXX` tests in `GPUTest` if possible. Otherwise these functions\n * require a device to give a correct answer.\n *\n * * isTextureFormatUsableAsRenderAttachment\n * * isTextureFormatColorRenderable\n * * isTextureFormatResolvable\n * * isTextureFormatBlendable\n * * isTextureFormatMultisampled\n * * isTextureFormatUsableAsStorageTexture\n * * isTextureFormatUsableAsReadWriteStorageTexture\n * * isTextureFormatUsableAsStorageFormatInCreateShaderModule\n * * isTextureFormatUsableWithCopyExternalImageToTexture\n *\n * Per-GPUTextureFormat info.\n */\nconst kTextureFormatInfo = {\n  ...kRegularTextureFormatInfo,\n  ...kSizedDepthStencilFormatInfo,\n  ...kUnsizedDepthStencilFormatInfo,\n  ...kBCTextureFormatInfo,\n  ...kETC2TextureFormatInfo,\n  ...kASTCTextureFormatInfo,\n} as const;\n\n/** Defining this variable verifies the type of kTextureFormatInfo2. It is not used. */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst kTextureFormatInfo_TypeCheck: {\n  readonly [F in GPUTextureFormat]: TextureFormatInfo_TypeCheck;\n} = kTextureFormatInfo;\n\n// Depth texture formats including formats that also support stencil\nexport const kDepthTextureFormats = [\n  ...kDepthStencilFormats.filter(v => kTextureFormatInfo[v].depth),\n] as const;\n// Stencil texture formats including formats that also support depth\nexport const kStencilTextureFormats = kDepthStencilFormats.filter(\n  v => kTextureFormatInfo[v].stencil\n);\n\nexport const kTextureFormatTier1AllowsResolve: readonly ColorTextureFormat[] = [\n  'r8snorm',\n  'rg8snorm',\n  'rgba8snorm',\n  'rg11b10ufloat',\n] as const;\n\nexport const kTextureFormatTier1ThrowsWhenNotEnabled: readonly ColorTextureFormat[] = [\n  'r16unorm',\n  'r16snorm',\n  'rg16unorm',\n  'rg16snorm',\n  'rgba16unorm',\n  'rgba16snorm',\n] as const;\n\nexport const kTextureFormatTier1AllowsRenderAttachmentBlendableMultisample: readonly ColorTextureFormat[] =\n  [\n    'r16unorm',\n    'r16snorm',\n    'rg16unorm',\n    'rg16snorm',\n    'rgba16unorm',\n    'rgba16snorm',\n    'r8snorm',\n    'rg8snorm',\n    'rgba8snorm',\n    'rg11b10ufloat',\n  ] as const;\n\nexport const kTextureFormatsTier1EnablesStorageReadOnlyWriteOnly: readonly ColorTextureFormat[] = [\n  'r8unorm',\n  'r8snorm',\n  'r8uint',\n  'r8sint',\n  'rg8unorm',\n  'rg8snorm',\n  'rg8uint',\n  'rg8sint',\n  'r16uint',\n  'r16sint',\n  'r16float',\n  'rg16uint',\n  'rg16sint',\n  'rg16float',\n  'rgb10a2uint',\n  'rgb10a2unorm',\n  'rg11b10ufloat',\n] as const;\n\nexport const kTextureFormatsTier2EnablesStorageReadWrite: readonly ColorTextureFormat[] = [\n  'r8unorm',\n  'r8uint',\n  'r8sint',\n  'rgba8unorm',\n  'rgba8uint',\n  'rgba8sint',\n  'r16uint',\n  'r16sint',\n  'r16float',\n  'rgba16uint',\n  'rgba16sint',\n  'rgba16float',\n  'rgba32uint',\n  'rgba32sint',\n  'rgba32float',\n] as const;\n\n// Texture formats that may possibly be used as a storage texture.\n// Some may require certain features to be enabled.\nexport const kPossibleStorageTextureFormats = [\n  ...kRegularTextureFormats.filter(f => kTextureFormatInfo[f].color?.storage),\n  'bgra8unorm',\n  // these can be used as storage when texture-formats-tier1 is enabled\n  ...kTextureFormatsTier1EnablesStorageReadOnlyWriteOnly,\n] as readonly RegularTextureFormat[];\n\n// Texture formats that may possibly be used as a storage texture.\n// Some may require certain features to be enabled.\nexport const kPossibleReadWriteStorageTextureFormats = [\n  ...kPossibleStorageTextureFormats.filter(f => kTextureFormatInfo[f].color?.readWriteStorage),\n  // these can be used as storage when texture-formats-tier2 is enabled\n  ...kTextureFormatsTier2EnablesStorageReadWrite,\n] as readonly RegularTextureFormat[];\n\n// Texture formats that may possibly be multisampled.\n// Some may require certain features to be enabled.\nexport const kPossibleMultisampledTextureFormats = [\n  ...kRegularTextureFormats.filter(f => kTextureFormatInfo[f].multisample),\n  ...kDepthStencilFormats.filter(f => kTextureFormatInfo[f].multisample),\n] as const;\n\n// Texture formats that may possibly be color renderable.\n// Some may require certain features to be enabled.\nexport const kPossibleColorRenderableTextureFormats = [\n  ...kRegularTextureFormats.filter(f => kTextureFormatInfo[f].colorRender),\n] as const;\nexport type PossibleColorRenderTextureFormat =\n  (typeof kPossibleColorRenderableTextureFormats)[number];\n\n// Texture formats that have a different base format. This is effectively all -srgb formats\n// including compressed formats.\nexport const kDifferentBaseFormatTextureFormats = kColorTextureFormats.filter(\n  f => kTextureFormatInfo[f].baseFormat && kTextureFormatInfo[f].baseFormat !== f\n);\n\n// \"Regular\" texture formats that have a different base format. This is effectively all -srgb formats\n// except compressed formats.\nexport const kDifferentBaseFormatRegularTextureFormats = kRegularTextureFormats.filter(\n  f => kTextureFormatInfo[f].baseFormat && kTextureFormatInfo[f].baseFormat !== f\n);\n\n// Textures formats that are optional\nexport const kOptionalTextureFormats = kAllTextureFormats.filter(\n  t => kTextureFormatInfo[t].feature !== undefined\n);\n\nfunction isSnormTextureFormat(format: GPUTextureFormat): boolean {\n  return format.endsWith('snorm');\n}\n\n/**\n * Returns true if a texture can be possibly used with copyExternalImageToTexture.\n * The texture may require certain features to be enabled.\n */\nexport function isTextureFormatPossiblyUsableWithCopyExternalImageToTexture(\n  format: GPUTextureFormat\n): boolean {\n  return (\n    isColorTextureFormat(format) &&\n    !isSintOrUintFormat(format) &&\n    !isCompressedTextureFormat(format) &&\n    !isSnormTextureFormat(format) &&\n    isTextureFormatPossiblyUsableAsColorRenderAttachment(format)\n  );\n}\n\n/**\n * Returns true if a texture can be used with copyExternalImageToTexture.\n */\nexport function isTextureFormatUsableWithCopyExternalImageToTexture(\n  features: GPUSupportedFeatures,\n  format: GPUTextureFormat\n): boolean {\n  return (\n    isColorTextureFormat(format) &&\n    !isSintOrUintFormat(format) &&\n    !isCompressedTextureFormat(format) &&\n    !isSnormTextureFormat(format) &&\n    isTextureFormatColorRenderable(features, format)\n  );\n}\n\n//\n// Other related stuff\n//\n\nconst kDepthStencilFormatCapabilityInBufferTextureCopy = {\n  // kUnsizedDepthStencilFormats\n  depth24plus: {\n    CopyB2T: [],\n    CopyT2B: [],\n    texelAspectSize: { 'depth-only': -1, 'stencil-only': -1 },\n  },\n  'depth24plus-stencil8': {\n    CopyB2T: ['stencil-only'],\n    CopyT2B: ['stencil-only'],\n    texelAspectSize: { 'depth-only': -1, 'stencil-only': 1 },\n  },\n\n  // kSizedDepthStencilFormats\n  depth16unorm: {\n    CopyB2T: ['all', 'depth-only'],\n    CopyT2B: ['all', 'depth-only'],\n    texelAspectSize: { 'depth-only': 2, 'stencil-only': -1 },\n  },\n  depth32float: {\n    CopyB2T: [],\n    CopyT2B: ['all', 'depth-only'],\n    texelAspectSize: { 'depth-only': 4, 'stencil-only': -1 },\n  },\n  'depth32float-stencil8': {\n    CopyB2T: ['stencil-only'],\n    CopyT2B: ['depth-only', 'stencil-only'],\n    texelAspectSize: { 'depth-only': 4, 'stencil-only': 1 },\n  },\n  stencil8: {\n    CopyB2T: ['all', 'stencil-only'],\n    CopyT2B: ['all', 'stencil-only'],\n    texelAspectSize: { 'depth-only': -1, 'stencil-only': 1 },\n  },\n} as const;\n\n/** `kDepthStencilFormatResolvedAspect[format][aspect]` returns the aspect-specific format for a\n *  depth-stencil format, or `undefined` if the format doesn't have the aspect.\n */\nexport const kDepthStencilFormatResolvedAspect: {\n  readonly [k in DepthStencilFormat]: {\n    readonly [a in GPUTextureAspect]: DepthStencilFormat | undefined;\n  };\n} = {\n  // kUnsizedDepthStencilFormats\n  depth24plus: {\n    all: 'depth24plus',\n    'depth-only': 'depth24plus',\n    'stencil-only': undefined,\n  },\n  'depth24plus-stencil8': {\n    all: 'depth24plus-stencil8',\n    'depth-only': 'depth24plus',\n    'stencil-only': 'stencil8',\n  },\n\n  // kSizedDepthStencilFormats\n  depth16unorm: {\n    all: 'depth16unorm',\n    'depth-only': 'depth16unorm',\n    'stencil-only': undefined,\n  },\n  depth32float: {\n    all: 'depth32float',\n    'depth-only': 'depth32float',\n    'stencil-only': undefined,\n  },\n  'depth32float-stencil8': {\n    all: 'depth32float-stencil8',\n    'depth-only': 'depth32float',\n    'stencil-only': 'stencil8',\n  },\n  stencil8: {\n    all: 'stencil8',\n    'depth-only': undefined,\n    'stencil-only': 'stencil8',\n  },\n} as const;\n\n/**\n * @returns the GPUTextureFormat corresponding to the @param aspect of @param format.\n * This allows choosing the correct format for depth-stencil aspects when creating pipelines that\n * will have to match the resolved format of views, or to get per-aspect information like the\n * `blockByteSize`.\n *\n * Many helpers use an `undefined` `aspect` to means `'all'` so this is also the default for this\n * function.\n */\nexport function resolvePerAspectFormat(\n  format: GPUTextureFormat,\n  aspect?: GPUTextureAspect\n): GPUTextureFormat {\n  if (aspect === 'all' || aspect === undefined) {\n    return format;\n  }\n  assert(!!kTextureFormatInfo[format].depth || !!kTextureFormatInfo[format].stencil);\n  const resolved = kDepthStencilFormatResolvedAspect[format as DepthStencilFormat][aspect ?? 'all'];\n  assert(resolved !== undefined);\n  return resolved;\n}\n\n/**\n * @returns the sample type of the specified aspect of the specified format.\n */\nexport function sampleTypeForFormatAndAspect(\n  format: GPUTextureFormat,\n  aspect: GPUTextureAspect\n): 'uint' | 'depth' | 'float' | 'sint' | 'unfilterable-float' {\n  const info = kTextureFormatInfo[format];\n  if (info.color) {\n    assert(aspect === 'all', `color format ${format} used with aspect ${aspect}`);\n    return info.color.type;\n  } else if (info.depth && info.stencil) {\n    if (aspect === 'depth-only') {\n      return info.depth.type;\n    } else if (aspect === 'stencil-only') {\n      return info.stencil.type;\n    } else {\n      unreachable(`depth-stencil format ${format} used with aspect ${aspect}`);\n    }\n  } else if (info.depth) {\n    assert(aspect !== 'stencil-only', `depth-only format ${format} used with aspect ${aspect}`);\n    return info.depth.type;\n  } else if (info.stencil) {\n    assert(aspect !== 'depth-only', `stencil-only format ${format} used with aspect ${aspect}`);\n    return info.stencil.type;\n  }\n  unreachable();\n}\n\n/**\n * Gets all copyable aspects for copies between texture and buffer for specified depth/stencil format and copy type, by spec.\n */\nexport function depthStencilFormatCopyableAspects(\n  type: ImageCopyType,\n  format: DepthStencilFormat\n): readonly GPUTextureAspect[] {\n  const appliedType = type === 'WriteTexture' ? 'CopyB2T' : type;\n  return kDepthStencilFormatCapabilityInBufferTextureCopy[format][appliedType];\n}\n\n/**\n * Computes whether a copy between a depth/stencil texture aspect and a buffer is supported, by spec.\n */\nexport function depthStencilBufferTextureCopySupported(\n  type: ImageCopyType,\n  format: DepthStencilFormat,\n  aspect: GPUTextureAspect\n): boolean {\n  const supportedAspects: readonly GPUTextureAspect[] = depthStencilFormatCopyableAspects(\n    type,\n    format\n  );\n  return supportedAspects.includes(aspect);\n}\n\n/**\n * Returns the byte size of the depth or stencil aspect of the specified depth/stencil format,\n * or -1 if none.\n */\nexport function depthStencilFormatAspectSize(\n  format: DepthStencilFormat,\n  aspect: 'depth-only' | 'stencil-only'\n) {\n  const texelAspectSize =\n    kDepthStencilFormatCapabilityInBufferTextureCopy[format].texelAspectSize[aspect];\n  assert(texelAspectSize > 0);\n  return texelAspectSize;\n}\n\n/**\n * Returns true iff a texture can be created with the provided GPUTextureDimension\n * (defaulting to 2d) and GPUTextureFormat, by spec.\n */\nexport function textureFormatAndDimensionPossiblyCompatible(\n  dimension: undefined | GPUTextureDimension,\n  format: GPUTextureFormat\n): boolean {\n  if (dimension === '3d' && (isBCTextureFormat(format) || isASTCTextureFormat(format))) {\n    return true;\n  }\n  const info = kAllTextureFormatInfo[format];\n  return !(\n    (dimension === '1d' || dimension === '3d') &&\n    (info.blockWidth > 1 || info.depth || info.stencil)\n  );\n}\n\n/**\n * Returns true iff a texture can be created with the provided GPUTextureDimension\n * (defaulting to 2d) and GPUTextureFormat for a GPU device, by spec.\n */\nexport function textureDimensionAndFormatCompatibleForDevice(\n  features: GPUSupportedFeatures,\n  dimension: undefined | GPUTextureDimension,\n  format: GPUTextureFormat\n): boolean {\n  if (\n    dimension === '3d' &&\n    ((isBCTextureFormat(format) && hasFeature(features, 'texture-compression-bc-sliced-3d')) ||\n      (isASTCTextureFormat(format) && hasFeature(features, 'texture-compression-astc-sliced-3d')))\n  ) {\n    return true;\n  }\n  const info = kAllTextureFormatInfo[format];\n  return !(\n    (dimension === '1d' || dimension === '3d') &&\n    (info.blockWidth > 1 || info.depth || info.stencil)\n  );\n}\n\n/**\n * Returns true iff a texture can be used with the provided GPUTextureViewDimension\n */\nexport function textureViewDimensionAndFormatCompatibleForDevice(\n  features: GPUSupportedFeatures,\n  dimension: GPUTextureViewDimension,\n  format: GPUTextureFormat\n): boolean {\n  return textureDimensionAndFormatCompatibleForDevice(\n    features,\n    getTextureDimensionFromView(dimension),\n    format\n  );\n}\n\n/**\n * Check if two formats are view format compatible.\n */\nexport function textureFormatsAreViewCompatible(\n  features: GPUSupportedFeatures,\n  a: GPUTextureFormat,\n  b: GPUTextureFormat\n) {\n  return isCompatibilityMode(features)\n    ? a === b\n    : a === b || a + '-srgb' === b || b + '-srgb' === a;\n}\n\n/**\n * Gets the block width, height, and bytes per block for a color texture format.\n * This is for color textures only. For all texture formats @see {@link getBlockInfoForTextureFormat}\n * The point of this function is bytesPerBlock is always defined so no need to check that it's not\n * vs getBlockInfoForTextureFormat where it may not be defined.\n */\nexport function getBlockInfoForColorTextureFormat(format: ColorTextureFormat) {\n  const info = kTextureFormatInfo[format];\n  return {\n    blockWidth: info.blockWidth,\n    blockHeight: info.blockHeight,\n    bytesPerBlock: info.color?.bytes,\n  };\n}\n\n/**\n * Gets the block width, height, and bytes per block for a sized texture format.\n * This is for sized textures only. For all texture formats @see {@link getBlockInfoForTextureFormat}\n * The point of this function is bytesPerBlock is always defined so no need to check that it's not\n * vs getBlockInfoForTextureFormat where it may not be defined.\n */\nexport function getBlockInfoForSizedTextureFormat(format: SizedTextureFormat) {\n  const info = kTextureFormatInfo[format];\n  const bytesPerBlock = info.color?.bytes || info.depth?.bytes || info.stencil?.bytes;\n  assert(!!bytesPerBlock);\n  return {\n    blockWidth: info.blockWidth,\n    blockHeight: info.blockHeight,\n    bytesPerBlock,\n  };\n}\n\n/**\n * Gets the block width, height, and bytes per block for an encodable texture format.\n * This is for encodable textures only. For all texture formats @see {@link getBlockInfoForTextureFormat}\n * The point of this function is bytesPerBlock is always defined so no need to check that it's not\n * vs getBlockInfoForTextureFormat where it may not be defined.\n */\nexport function getBlockInfoForEncodableTextureFormat(format: EncodableTextureFormat) {\n  const info = kTextureFormatInfo[format];\n  const bytesPerBlock = info.color?.bytes || info.depth?.bytes || info.stencil?.bytes;\n  assert(!!bytesPerBlock);\n  return {\n    blockWidth: info.blockWidth,\n    blockHeight: info.blockHeight,\n    bytesPerBlock,\n  };\n}\n\n/**\n * Gets the block width, height, and bytes per block for a color texture format.\n * Note that bytesPerBlock will be undefined if format's size is undefined.\n * If you are only using color or encodable formats, @see {@link getBlockInfoForColorTextureFormat}\n * or {@link getBlockInfoForEncodableTextureFormat}\n */\nexport function getBlockInfoForTextureFormat(format: GPUTextureFormat) {\n  const info = kTextureFormatInfo[format];\n  return {\n    blockWidth: info.blockWidth,\n    blockHeight: info.blockHeight,\n    bytesPerBlock: info.color?.bytes ?? info.depth?.bytes ?? info.stencil?.bytes,\n  };\n}\n\n/**\n * Returns the \"byteCost\" of rendering to a color texture format.\n */\nexport function getColorRenderByteCost(format: PossibleColorRenderTextureFormat) {\n  const byteCost = kTextureFormatInfo[format].colorRender?.byteCost;\n  // MAINTENANCE_TODO: remove this assert. The issue is typescript thinks\n  // PossibleColorRenderTextureFormat contains all texture formats and not just\n  // a filtered list.\n  assert(byteCost !== undefined);\n  return byteCost;\n}\n\n/**\n * Returns the \"alignment\" of rendering to a color texture format.\n */\nexport function getColorRenderAlignment(format: PossibleColorRenderTextureFormat) {\n  const alignment = kTextureFormatInfo[format].colorRender?.alignment;\n  // MAINTENANCE_TODO: remove this assert. The issue is typescript thinks\n  // PossibleColorRenderTextureFormat contains all texture formats and not just\n  // a filtered list.\n  assert(alignment !== undefined);\n  return alignment;\n}\n\n/**\n * Gets the baseFormat for a texture format.\n */\nexport function getBaseFormatForTextureFormat(\n  format: (typeof kDifferentBaseFormatTextureFormats)[number]\n): ColorTextureFormat {\n  return kTextureFormatInfo[format].baseFormat!;\n}\n\nexport function getBaseFormatForRegularTextureFormat(\n  format: RegularTextureFormat\n): RegularTextureFormat | undefined {\n  return kTextureFormatInfo[format].baseFormat as RegularTextureFormat;\n}\n\n/**\n * Gets the feature needed for a give texture format or undefined if none.\n */\nexport function getRequiredFeatureForTextureFormat(format: GPUTextureFormat) {\n  return kTextureFormatInfo[format].feature;\n}\n\nexport function getFeaturesForFormats<T>(\n  formats: readonly (T & (GPUTextureFormat | undefined))[]\n): readonly (GPUFeatureName | undefined)[] {\n  return Array.from(new Set(formats.map(f => (f ? kTextureFormatInfo[f].feature : undefined))));\n}\n\nexport function filterFormatsByFeature<T>(\n  feature: GPUFeatureName | undefined,\n  formats: readonly (T & (GPUTextureFormat | undefined))[]\n): readonly (T & (GPUTextureFormat | undefined))[] {\n  return formats.filter(f => f === undefined || kTextureFormatInfo[f].feature === feature);\n}\n\nfunction isTextureFormatTier1EnablesRenderAttachmentBlendableMultisample(format: GPUTextureFormat) {\n  return kTextureFormatTier1AllowsRenderAttachmentBlendableMultisample.includes(\n    format as ColorTextureFormat\n  );\n}\n\nfunction isTextureFormatTier1EnablesResolve(format: GPUTextureFormat) {\n  return kTextureFormatTier1AllowsResolve.includes(format as ColorTextureFormat);\n}\n\nfunction isTextureFormatTier1EnablesStorageReadOnlyWriteOnly(format: GPUTextureFormat) {\n  return kTextureFormatsTier1EnablesStorageReadOnlyWriteOnly.includes(format as ColorTextureFormat);\n}\n\nfunction isTextureFormatTier2EnablesStorageReadWrite(format: GPUTextureFormat) {\n  return kTextureFormatsTier2EnablesStorageReadWrite.includes(format as ColorTextureFormat);\n}\n\nexport function canCopyToAspectOfTextureFormat(format: GPUTextureFormat, aspect: GPUTextureAspect) {\n  const info = kTextureFormatInfo[format];\n  switch (aspect) {\n    case 'depth-only':\n      assert(isDepthTextureFormat(format));\n      return info.depth && info.depth.copyDst;\n    case 'stencil-only':\n      assert(isStencilTextureFormat(format));\n      return info.stencil && info.stencil.copyDst;\n    case 'all':\n      return (\n        (!isDepthTextureFormat(format) || info.depth?.copyDst) &&\n        (!isStencilTextureFormat(format) || info.stencil?.copyDst) &&\n        (!isColorTextureFormat(format) || !info.color?.copyDst)\n      );\n  }\n}\n\nexport function canCopyFromAspectOfTextureFormat(\n  format: GPUTextureFormat,\n  aspect: GPUTextureAspect\n) {\n  const info = kTextureFormatInfo[format];\n  switch (aspect) {\n    case 'depth-only':\n      assert(isDepthTextureFormat(format));\n      return info.depth && info.depth.copySrc;\n    case 'stencil-only':\n      assert(isStencilTextureFormat(format));\n      return info.stencil && info.stencil.copySrc;\n    case 'all':\n      return (\n        (!isDepthTextureFormat(format) || info.depth?.copySrc) &&\n        (!isStencilTextureFormat(format) || info.stencil?.copySrc) &&\n        (!isColorTextureFormat(format) || !info.color?.copySrc)\n      );\n  }\n}\n\n/**\n * Returns true if all aspects of texture can be copied to (used with COPY_DST)\n */\nexport function canCopyToAllAspectsOfTextureFormat(format: GPUTextureFormat) {\n  const info = kTextureFormatInfo[format];\n  return (\n    (!info.color || info.color.copyDst) &&\n    (!info.depth || info.depth.copyDst) &&\n    (!info.stencil || info.stencil.copyDst)\n  );\n}\n\n/**\n * Returns true if all aspects of texture can be copied from (used with COPY_SRC)\n */\nexport function canCopyFromAllAspectsOfTextureFormat(format: GPUTextureFormat) {\n  const info = kTextureFormatInfo[format];\n  return (\n    (!info.color || info.color.copySrc) &&\n    (!info.depth || info.depth.copySrc) &&\n    (!info.stencil || info.stencil.copySrc)\n  );\n}\n\nexport function isCompressedTextureFormat(format: GPUTextureFormat) {\n  return format in kCompressedTextureFormatInfo;\n}\n\nexport function isBCTextureFormat(format: GPUTextureFormat) {\n  return format in kBCTextureFormatInfo;\n}\n\nexport function isASTCTextureFormat(format: GPUTextureFormat) {\n  return format in kASTCTextureFormatInfo;\n}\n\nexport function isColorTextureFormat(format: GPUTextureFormat) {\n  return !!kTextureFormatInfo[format].color;\n}\n\nexport function isDepthTextureFormat(format: GPUTextureFormat) {\n  return !!kTextureFormatInfo[format].depth;\n}\n\nexport function isStencilTextureFormat(format: GPUTextureFormat) {\n  return !!kTextureFormatInfo[format].stencil;\n}\n\nexport function isDepthStencilTextureFormat(format: GPUTextureFormat) {\n  return isDepthTextureFormat(format) && isStencilTextureFormat(format);\n}\n\nexport function isDepthOrStencilTextureFormat(format: GPUTextureFormat) {\n  return isDepthTextureFormat(format) || isStencilTextureFormat(format);\n}\n\nexport function isEncodableTextureFormat(format: GPUTextureFormat) {\n  return kEncodableTextureFormats.includes(format as EncodableTextureFormat);\n}\n\n/**\n * Returns if a texture can be used as a render attachment. some color formats and all\n * depth textures and stencil textures are usable with usage RENDER_ATTACHMENT.\n */\nexport function isTextureFormatUsableAsRenderAttachment(\n  features: GPUSupportedFeatures,\n  format: GPUTextureFormat\n) {\n  if (format === 'rg11b10ufloat') {\n    return hasFeature(features, 'rg11b10ufloat-renderable');\n  }\n  if (isTextureFormatTier1EnablesRenderAttachmentBlendableMultisample(format)) {\n    return hasFeature(features, 'texture-formats-tier1');\n  }\n  return !!(kTextureFormatInfo[format].colorRender || isDepthOrStencilTextureFormat(format));\n}\n\n/**\n * Returns if a texture can be used as a \"colorAttachment\".\n */\nexport function isTextureFormatColorRenderable(\n  features: GPUSupportedFeatures,\n  format: GPUTextureFormat\n): boolean {\n  if (format === 'rg11b10ufloat') {\n    return hasFeature(features, 'rg11b10ufloat-renderable');\n  }\n  if (isTextureFormatTier1EnablesRenderAttachmentBlendableMultisample(format)) {\n    return hasFeature(features, 'texture-formats-tier1');\n  }\n  return !!kAllTextureFormatInfo[format].colorRender;\n}\n\n/**\n * Returns if a texture can be blended.\n */\nexport function isTextureFormatBlendable(\n  features: GPUSupportedFeatures,\n  format: GPUTextureFormat\n): boolean {\n  if (!isTextureFormatColorRenderable(features, format)) {\n    return false;\n  }\n  if (format === 'rg11b10ufloat') {\n    return hasFeature(features, 'rg11b10ufloat-renderable');\n  }\n  if (is32Float(format)) {\n    return hasFeature(features, 'float32-blendable');\n  }\n  return !!kAllTextureFormatInfo[format].colorRender?.blend;\n}\n\n/**\n * Returns true if a texture can be filtered.\n */\nexport function isTextureFormatFilterable(\n  features: GPUSupportedFeatures,\n  format: GPUTextureFormat\n): boolean {\n  const type = getTextureFormatType(format);\n  switch (type) {\n    case 'float':\n      return true;\n    case 'unfilterable-float':\n      assert(is32Float(format));\n      return hasFeature(features, 'float32-filterable');\n    default:\n      return false;\n  }\n}\n\n/**\n * Returns the texture's type (float, unsigned-float, sint, uint, depth)\n */\nexport function getTextureFormatType(format: GPUTextureFormat, aspect: GPUTextureAspect = 'all') {\n  const info = kTextureFormatInfo[format];\n  let type;\n  switch (aspect) {\n    case 'all':\n      type = info.color?.type ?? info.depth?.type ?? info.stencil?.type;\n      break;\n    case 'depth-only':\n      type = info.depth?.type;\n      break;\n    case 'stencil-only':\n      type = info.stencil?.type;\n      break;\n  }\n  assert(!!type);\n  return type;\n}\n\n/**\n * Returns the regular texture's type (float, unsigned-float, sint, uint)\n */\nexport function getTextureFormatColorType(format: RegularTextureFormat) {\n  const info = kTextureFormatInfo[format];\n  const type = info.color?.type;\n  assert(!!type);\n  return type;\n}\n\n/**\n * Returns true if a texture can possibly be used as a render attachment.\n * The texture may require certain features to be enabled.\n */\nexport function isTextureFormatPossiblyUsableAsRenderAttachment(format: GPUTextureFormat) {\n  const info = kTextureFormatInfo[format];\n  return (\n    isDepthOrStencilTextureFormat(format) ||\n    !!info.colorRender ||\n    isTextureFormatTier1EnablesRenderAttachmentBlendableMultisample(format)\n  );\n}\n\n/**\n * Returns true if a texture can possibly be used as a color render attachment.\n * The texture may require certain features to be enabled.\n */\nexport function isTextureFormatPossiblyUsableAsColorRenderAttachment(format: GPUTextureFormat) {\n  const info = kTextureFormatInfo[format];\n  return (\n    !!info.colorRender || isTextureFormatTier1EnablesRenderAttachmentBlendableMultisample(format)\n  );\n}\n\n/**\n * Returns true if a texture can possibly be used multisampled.\n * The texture may require certain features to be enabled.\n */\nexport function isTextureFormatPossiblyMultisampled(format: GPUTextureFormat) {\n  const info = kTextureFormatInfo[format];\n  return (\n    info.multisample || isTextureFormatTier1EnablesRenderAttachmentBlendableMultisample(format)\n  );\n}\n\n/**\n * Returns true if a texture can possibly be resolved.\n * The texture may require certain features to be enabled.\n */\nexport function isTextureFormatPossiblyResolvable(format: GPUTextureFormat) {\n  if (format === 'rg11b10ufloat') {\n    return true;\n  }\n  if (isTextureFormatTier1EnablesResolve(format)) {\n    return true;\n  }\n  const info = kTextureFormatInfo[format];\n  return !!info.colorRender?.resolve;\n}\n\n/**\n * Returns true if a texture can possibly be used as a storage texture.\n * The texture may require certain features to be enabled.\n */\nexport function isTextureFormatPossiblyStorageReadable(format: GPUTextureFormat) {\n  return (\n    !!kTextureFormatInfo[format].color?.storage ||\n    isTextureFormatTier1EnablesStorageReadOnlyWriteOnly(format)\n  );\n}\n\n/**\n * Returns true if a texture can possibly be used as a read-write storage texture.\n * The texture may require certain features to be enabled.\n */\nexport function isTextureFormatPossiblyStorageReadWritable(format: GPUTextureFormat) {\n  return (\n    !!kTextureFormatInfo[format].color?.readWriteStorage ||\n    isTextureFormatTier2EnablesStorageReadWrite(format)\n  );\n}\n\nexport function is16Float(format: GPUTextureFormat) {\n  return format === 'r16float' || format === 'rg16float' || format === 'rgba16float';\n}\n\nexport function is32Float(format: GPUTextureFormat) {\n  return format === 'r32float' || format === 'rg32float' || format === 'rgba32float';\n}\n\n/**\n * Returns true if texture is filterable as `texture_xxx<f32>`\n *\n * examples:\n * * 'rgba8unorm' -> true\n * * 'depth16unorm' -> false\n * * 'rgba32float' -> true (you need to enable feature 'float32-filterable')\n */\nexport function isTextureFormatPossiblyFilterableAsTextureF32(format: GPUTextureFormat) {\n  const info = kTextureFormatInfo[format];\n  return info.color?.type === 'float' || is32Float(format);\n}\n\nexport const kCompatModeUnsupportedStorageTextureFormats: readonly GPUTextureFormat[] = [\n  'rg32float',\n  'rg32sint',\n  'rg32uint',\n] as const;\n\n/**\n * Return true if the format can be used as a write only storage texture.\n * Note: Some formats can be compiled in a shader but can not be used\n * in a pipeline or elsewhere. This function returns whether or not the format\n * can be used in general. If you want to know if the format can used when compiling\n * a shader @see {@link isTextureFormatUsableAsStorageFormatInCreateShaderModule}\n */\nfunction isTextureFormatUsableAsWriteOnlyStorageTexture(\n  features: GPUSupportedFeatures,\n  format: GPUTextureFormat\n): boolean {\n  if (isCompatibilityMode(features)) {\n    if (kCompatModeUnsupportedStorageTextureFormats.indexOf(format) >= 0) {\n      return false;\n    }\n  }\n  if (format === 'bgra8unorm' && hasFeature(features, 'bgra8unorm-storage')) {\n    return true;\n  }\n  if (\n    isTextureFormatTier1EnablesStorageReadOnlyWriteOnly(format) &&\n    hasFeature(features, 'texture-formats-tier1')\n  ) {\n    return true;\n  }\n  const info = kTextureFormatInfo[format];\n  return !!(info.color?.storage || info.depth?.storage || info.stencil?.storage);\n}\n\n/**\n * Return true if the format can be used with the given access mode\n * access can be either GPUStorageTextureAccess or WGSL access\n * Note: Some formats can be compiled in a shader but can not be used\n * in a pipeline or elsewhere. This function returns whether or not the format\n * can be used in general. If you want to know if the format can used when compiling\n * a shader @see {@link isTextureFormatUsableAsStorageFormatInCreateShaderModule}\n */\nexport function isTextureFormatUsableWithStorageAccessMode(\n  features: GPUSupportedFeatures,\n  format: GPUTextureFormat,\n  access: GPUStorageTextureAccess | 'read' | 'write' | 'read_write'\n) {\n  switch (access) {\n    case 'read':\n    case 'read-only':\n      return isTextureFormatUsableAsReadOnlyStorageTexture(features, format);\n    case 'write':\n    case 'write-only':\n      return isTextureFormatUsableAsWriteOnlyStorageTexture(features, format);\n    case 'read_write':\n    case 'read-write':\n      return isTextureFormatUsableAsReadWriteStorageTexture(features, format);\n  }\n}\n\n/**\n * Return true if the format can be used as a read only storage texture.\n * Note: Some formats can be compiled in a shader but can not be used\n * in a pipeline or elsewhere. This function returns whether or not the format\n * can be used in general. If you want to know if the format can used when compiling\n * a shader @see {@link isTextureFormatUsableAsStorageFormatInCreateShaderModule}\n */\nfunction isTextureFormatUsableAsReadOnlyStorageTexture(\n  features: GPUSupportedFeatures,\n  format: GPUTextureFormat\n): boolean {\n  // This is the only storage texture format that isn't readable as a storage format.\n  if (format === 'bgra8unorm') {\n    return false;\n  }\n  // All other formats that can be used as a storage texture can be used as\n  // both read-only and write-only.\n  return isTextureFormatUsableAsWriteOnlyStorageTexture(features, format);\n}\n\n/**\n * Returns true if format can be used with createShaderModule on the device.\n * Some formats may require a feature to be enabled before they can be used\n * as a storage texture. Others, can't be used in a pipeline but can be compiled\n * in a shader. Examples are rg32float, rg32uint, rg32sint which are not usable\n * in compat mode but shaders can be compiled. Similarly, bgra8unorm can be\n * compiled but can't be used in a pipeline unless feature 'bgra8unorm-storage'\n * is available.\n */\nexport function isTextureFormatUsableAsStorageFormatInCreateShaderModule(\n  features: GPUSupportedFeatures,\n  format: GPUTextureFormat\n): boolean {\n  return kPossibleStorageTextureFormats.includes(\n    format as (typeof kPossibleStorageTextureFormats)[number]\n  );\n}\n\nfunction isTextureFormatUsableAsReadWriteStorageTexture(\n  features: GPUSupportedFeatures,\n  format: GPUTextureFormat\n): boolean {\n  if (isTextureFormatTier2EnablesStorageReadWrite(format)) {\n    return hasFeature(features, 'texture-formats-tier2');\n  }\n  return !!kTextureFormatInfo[format].color?.readWriteStorage;\n}\n\nexport function isRegularTextureFormat(format: GPUTextureFormat) {\n  return format in kRegularTextureFormatInfo;\n}\n\n/**\n * Returns true if format is both compressed and a float format, for example 'bc6h-rgb-ufloat'.\n */\nexport function isCompressedFloatTextureFormat(format: GPUTextureFormat) {\n  return isCompressedTextureFormat(format) && format.includes('float');\n}\n\n/**\n * Returns true if format is sint or uint\n */\nexport function isSintOrUintFormat(format: GPUTextureFormat) {\n  const info = kTextureFormatInfo[format];\n  const type = info.color?.type ?? info.depth?.type ?? info.stencil?.type;\n  return type === 'sint' || type === 'uint';\n}\n\n/**\n * Returns true if format can be multisampled.\n */\nexport const kCompatModeUnsupportedMultisampledTextureFormats: readonly GPUTextureFormat[] = [\n  'r8uint',\n  'r8sint',\n  'rg8uint',\n  'rg8sint',\n  'rgba8uint',\n  'rgba8sint',\n  'r16uint',\n  'r16sint',\n  'rg16uint',\n  'rg16sint',\n  'rgba16uint',\n  'rgba16sint',\n  'rgb10a2uint',\n  'rgba16float',\n  'r32float',\n] as const;\n\n/**\n * Returns true if you can make a multisampled texture from the given format.\n */\nexport function isTextureFormatMultisampled(\n  features: GPUSupportedFeatures,\n  format: GPUTextureFormat\n): boolean {\n  if (isCompatibilityMode(features)) {\n    if (kCompatModeUnsupportedMultisampledTextureFormats.indexOf(format) >= 0) {\n      return false;\n    }\n  }\n  if (format === 'rg11b10ufloat') {\n    return hasFeature(features, 'rg11b10ufloat-renderable');\n  }\n  if (isTextureFormatTier1EnablesRenderAttachmentBlendableMultisample(format)) {\n    return hasFeature(features, 'texture-formats-tier1');\n  }\n  return kAllTextureFormatInfo[format].multisample;\n}\n\n/**\n * Returns true if a texture can be \"resolved\". uint/sint formats can be multisampled but\n * can not be resolved.\n */\nexport function isTextureFormatResolvable(\n  features: GPUSupportedFeatures,\n  format: GPUTextureFormat\n): boolean {\n  if (format === 'rg11b10ufloat') {\n    return hasFeature(features, 'rg11b10ufloat-renderable');\n  }\n  if (isTextureFormatTier1EnablesResolve(format)) {\n    return hasFeature(features, 'texture-formats-tier1');\n  }\n  // You can't resolve a non-multisampled format.\n  if (!isTextureFormatMultisampled(features, format)) {\n    return false;\n  }\n  const info = kAllTextureFormatInfo[format];\n  return !!info.colorRender?.resolve;\n}\n\n// MAINTENANCE_TODD: See if we can remove this. This doesn't seem useful since\n// formats are not on/off by feature. Some are on but a feature allows them to be\n// used in more cases, like going from un-renderable to renderable, etc...\nexport const kFeaturesForFormats = getFeaturesForFormats(kAllTextureFormats);\n\n/**\n * Given an array of texture formats return the number of bytes per sample.\n */\nexport function computeBytesPerSampleFromFormats(formats: readonly GPUTextureFormat[]) {\n  let bytesPerSample = 0;\n  for (const format of formats) {\n    // MAINTENANCE_TODO: Add colorRender to rg11b10ufloat format in kTextureFormatInfo\n    // The issue is if we add it now lots of tests will break as they'll think they can\n    // render to the format but are not enabling 'rg11b10ufloat-renderable'. Once we\n    // get the CTS refactored (see issue 4181), then fix this.\n    const info = kTextureFormatInfo[format];\n    const alignedBytesPerSample = align(bytesPerSample, info.colorRender!.alignment);\n    bytesPerSample = alignedBytesPerSample + info.colorRender!.byteCost;\n  }\n  return bytesPerSample;\n}\n\n/**\n * Given an array of GPUColorTargetState return the number of bytes per sample\n */\nexport function computeBytesPerSample(targets: GPUColorTargetState[]) {\n  return computeBytesPerSampleFromFormats(targets.map(({ format }) => format));\n}\n\n/**\n * Returns the maximum valid size in each dimension for a given texture format.\n * This is useful because compressed formats must be a multiple of blocks in size\n * so, for example, the largest valid width of a 2d texture\n * roundDown(device.limits.maxTextureDimension2D, blockWidth)\n */\nexport function getMaxValidTextureSizeForFormatAndDimension(\n  device: GPUDevice,\n  format: GPUTextureFormat,\n  dimension: GPUTextureDimension\n): [number, number, number] {\n  const info = getBlockInfoForTextureFormat(format);\n  switch (dimension) {\n    case '1d':\n      return [device.limits.maxTextureDimension1D, 1, 1];\n    case '2d':\n      return [\n        roundDown(device.limits.maxTextureDimension2D, info.blockWidth),\n        roundDown(device.limits.maxTextureDimension2D, info.blockHeight),\n        device.limits.maxTextureArrayLayers,\n      ];\n    case '3d':\n      return [\n        roundDown(device.limits.maxTextureDimension3D, info.blockWidth),\n        roundDown(device.limits.maxTextureDimension3D, info.blockHeight),\n        device.limits.maxTextureDimension3D,\n      ];\n  }\n}\n","import {\n  isTextureFormatBlendable,\n  isTextureFormatColorRenderable,\n  isTextureFormatFilterable,\n  isTextureFormatMultisampled,\n  isTextureFormatResolvable,\n  isTextureFormatUsableAsRenderAttachment,\n  isTextureFormatUsableWithCopyExternalImageToTexture,\n  isTextureFormatUsableWithStorageAccessMode,\n  isCompressedTextureFormat,\n  depthStencilBufferTextureCopySupported,\n  getRequiredFeatureForTextureFormat,\n  isDepthOrStencilTextureFormat,\n  ImageCopyType,\n  DepthStencilFormat,\n //ColorTextureFormat,\n //SizedTextureFormat,\n //UncompressedTextureFormat,\n //kColorTextureFormats,\n //kSizedTextureFormats,\n //kDepthStencilFormats,\n //kUncompressedTextureFormats,\n //kAllTextureFormats,\n  getBlockInfoForTextureFormat as getBlockInfoForTextureFormatImpl,\n} from './format_info.js';\nimport { isCompatibilityMode } from './utils.js';\n\nexport {\n  ImageCopyType,\n  //ColorTextureFormat,\n  //SizedTextureFormat,\n  //DepthStencilFormat,\n  //UncompressedTextureFormat,\n  //kColorTextureFormats,\n  //kSizedTextureFormats,\n  //kDepthStencilFormats,\n  //kUncompressedTextureFormats,\n  //kAllTextureFormats,\n};\n\n/**\n * Features supported by a texture format.\n */\nexport type TextureSupportedFeatures = {\n  supported: boolean,  // if this is false all others will be false\n  multisample: boolean,\n  resolvable: boolean,  // not all multisampled textures can be resolved. Example: sint/uint textures\n  blendable: boolean,\n  filterable: boolean,\n  colorRenderable: boolean,  // can be used as a color render attachment\n  renderAttachment: boolean,  // can be used as one or more of color OR depth OR depth-stencil attachment\n  copyExternalImageToTexture: boolean,\n  storageReadOnly: boolean,\n  storageWriteOnly: boolean,\n  storageReadWrite: boolean,\n};\n\n/**\n * Returns the size of a block for a given texture format\n * For a depth-stencil format it return the size of the depth aspect\n * unless you specify the stencil-only aspect.\n */\nexport function getBlockInfoForTextureFormat(format: GPUTextureFormat, aspect: GPUTextureAspect = 'all') {\n  if (aspect === 'stencil-only') {\n    format = 'stencil8';\n  } else if (format === 'depth24plus' || format === 'depth24plus-stencil8') {\n    return { blockWidth: 1, blockHeight: 1 };\n  }\n  return getBlockInfoForTextureFormatImpl(format);\n}\n\n/**\n * For a given texture format, check if you can call `writeTexture`,\n * `copyBufferToTexture`, `copyTextureToBuffer`, and `copyTextureToTexture`\n */\nexport function copySupported(\n  features: GPUSupportedFeatures,\n  type: ImageCopyType | 'CopyT2T',\n  format: GPUTextureFormat,\n  aspect: GPUTextureAspect,\n  sampleCount = 1,\n) {\n  if (isCompatibilityMode(features)) {\n    if (sampleCount > 1 && type === 'CopyT2T') {\n      return false;\n    }\n    if (isCompressedTextureFormat(format)) {\n      return type === 'WriteTexture' || type === 'CopyB2T';\n    }\n  }\n\n  if (isDepthOrStencilTextureFormat(format)) {\n    switch (type) {\n      case 'CopyT2T': {\n        switch (format) {\n          case 'depth24plus':\n          case 'depth32float':\n            return false;\n          case 'depth24plus-stencil8':\n          case 'depth32float-stencil8':\n            return aspect === 'stencil-only';\n        }\n        break;\n      }\n      default:\n        return depthStencilBufferTextureCopySupported(type, format as DepthStencilFormat, aspect);\n    }\n  }\n  return sampleCount == 1 || type === 'CopyT2T';\n}\n\nfunction isTextureFormatSupported(features: GPUSupportedFeatures, format: GPUTextureFormat) {\n  if (format === 'bgra8unorm-srgb') {\n    if (isCompatibilityMode(features)) {\n      return false;\n    }\n  }\n  const feature = getRequiredFeatureForTextureFormat(format);\n  return !feature || features.has(feature);\n}\n\n/**\n * Returns, for the given device, what features a texture supports.\n */\nexport function getTextureSupportedFeatures(features: GPUSupportedFeatures, format: GPUTextureFormat) : TextureSupportedFeatures {\n  const supported = isTextureFormatSupported(features, format);\n  return {\n    supported,\n    multisample: supported && isTextureFormatMultisampled(features, format),\n    resolvable: supported && isTextureFormatResolvable(features, format),\n    blendable: supported && isTextureFormatBlendable(features, format),\n    filterable: supported && isTextureFormatFilterable(features, format),\n    colorRenderable: supported && isTextureFormatColorRenderable(features, format),\n    renderAttachment: supported && isTextureFormatUsableAsRenderAttachment(features, format),\n    copyExternalImageToTexture: supported && isTextureFormatUsableWithCopyExternalImageToTexture(features, format),\n    storageReadOnly: supported && isTextureFormatUsableWithStorageAccessMode(features, format, 'read'),\n    storageWriteOnly: supported && isTextureFormatUsableWithStorageAccessMode(features, format, 'write'),\n    storageReadWrite: supported && isTextureFormatUsableWithStorageAccessMode(features, format, 'read-write'),\n  };\n}\n\n"],"names":["keysOf","obj","Object","keys","hasFeature","features","feature","has","isCompatibilityMode","assert","condition","msg","Error","kFormatUniversalDefaults","blockWidth","undefined","blockHeight","color","depth","stencil","colorRender","multisample","baseFormat","bytesPerBlock","formatTableWithDefaults","defaults","table","fromEntries","entries","map","k","row","kRegularTextureFormatInfo","r8unorm","type","copySrc","copyDst","storage","readWriteStorage","bytes","blend","resolve","byteCost","alignment","this","r8snorm","r8uint","r8sint","rg8unorm","rg8snorm","rg8uint","rg8sint","rgba8unorm","rgba8snorm","rgba8uint","rgba8sint","bgra8unorm","r16unorm","r16snorm","r16uint","r16sint","r16float","rg16unorm","rg16snorm","rg16uint","rg16sint","rg16float","rgba16unorm","rgba16snorm","rgba16uint","rgba16sint","rgba16float","r32uint","r32sint","r32float","rg32uint","rg32sint","rg32float","rgba32uint","rgba32sint","rgba32float","rgb10a2uint","rgb10a2unorm","rg11b10ufloat","rgb9e5ufloat","kSizedDepthStencilFormatInfo","stencil8","depth16unorm","depth32float","kUnsizedDepthStencilFormatInfo","depth24plus","kBCTextureFormatInfo","kETC2TextureFormatInfo","kASTCTextureFormatInfo","kCompressedTextureFormatInfo","kColorTextureFormatInfo","kDepthStencilFormatInfo","kAllTextureFormatInfo","kRegularTextureFormats","kColorTextureFormats","kDepthStencilFormats","kAllTextureFormats","kTextureFormatInfo","filter","v","kTextureFormatTier1AllowsResolve","kTextureFormatTier1AllowsRenderAttachmentBlendableMultisample","kTextureFormatsTier1EnablesStorageReadOnlyWriteOnly","kTextureFormatsTier2EnablesStorageReadWrite","isTextureFormatUsableWithCopyExternalImageToTexture","format","isColorTextureFormat","info","isSintOrUintFormat","isCompressedTextureFormat","endsWith","isSnormTextureFormat","isTextureFormatColorRenderable","f","t","kDepthStencilFormatCapabilityInBufferTextureCopy","CopyB2T","CopyT2B","texelAspectSize","depthStencilBufferTextureCopySupported","aspect","supportedAspects","depthStencilFormatCopyableAspects","includes","isTextureFormatTier1EnablesRenderAttachmentBlendableMultisample","isDepthOrStencilTextureFormat","isDepthTextureFormat","isStencilTextureFormat","isTextureFormatUsableAsRenderAttachment","isTextureFormatBlendable","is32Float","isTextureFormatFilterable","getTextureFormatType","kCompatModeUnsupportedStorageTextureFormats","isTextureFormatUsableAsWriteOnlyStorageTexture","indexOf","isTextureFormatTier1EnablesStorageReadOnlyWriteOnly","isTextureFormatUsableWithStorageAccessMode","access","isTextureFormatUsableAsReadOnlyStorageTexture","isTextureFormatTier2EnablesStorageReadWrite","isTextureFormatUsableAsReadWriteStorageTexture","kCompatModeUnsupportedMultisampledTextureFormats","isTextureFormatMultisampled","isTextureFormatResolvable","isTextureFormatTier1EnablesResolve","formats","getBlockInfoForTextureFormat","getBlockInfoForTextureFormatImpl","copySupported","sampleCount","isTextureFormatSupported","getRequiredFeatureForTextureFormat","getTextureSupportedFeatures","supported","resolvable","blendable","filterable","colorRenderable","renderAttachment","copyExternalImageToTexture","storageReadOnly","storageWriteOnly","storageReadWrite","Array","from","Set"],"mappings":"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"}